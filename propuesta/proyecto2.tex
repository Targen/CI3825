\documentclass[]{article}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifxetex
  \usepackage{fontspec,xltxtra,xunicode}
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
\else
  \ifluatex
    \usepackage{fontspec}
    \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \else
    \usepackage[utf8]{inputenc}
  \fi
\fi
\usepackage{color}
\usepackage{fancyvrb}
\DefineShortVerb[commandchars=\\\{\}]{\|}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
% Redefine labelwidth for lists; otherwise, the enumerate package will cause
% markers to extend beyond the left margin.
\makeatletter\AtBeginDocument{%
  \renewcommand{\@listi}
    {\setlength{\labelwidth}{4em}}
}\makeatother
\usepackage{enumerate}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex,
              colorlinks=true,
              linkcolor=blue]{hyperref}
\else
  \usepackage[unicode=true,
              colorlinks=true,
              linkcolor=blue]{hyperref}
\fi
\hypersetup{breaklinks=true, pdfborder={0 0 0}}
\usepackage[normalem]{ulem}
% avoid problems with \sout in headers with hyperref:
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\newcommand{\textsubscr}[1]{\ensuremath{_{\scriptsize\textrm{#1}}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\usepackage[margin=2.5cm]{geometry}
\renewcommand{\contentsname}{Contenido}

\title{Proyecto 2: \texttt{rautomake}: El generador de \texttt{Makefile}s}
\author{CI3825 (Sistemas de operación I)}
\date{Enero--Marzo 2012}

\begin{document}
\maketitle

\tableofcontents

\begin{center}\rule{3in}{0.4pt}\end{center}

\textbf{Este documento es solo una propuesta y no contiene
requerimientos para ninguna evaluación. No debe suponerse que alguna
evaluación vaya a ser basada en él a menos que sea publicado
oficialmente por los profesores a cargo del curso; en ese caso, la
versión normativa del documento será la que se publique, que no
contendrá esta nota, y esta versión será considerada inválida y no
deberá ser usada como referencia para ningún propósito.}

Este documento es un borrador, y se espera que tenga deficiencias de
diseño, del redacción, orthografícas y d\emph{e}
t\textbf{ipo}g\textsuperscript{r}a\sout{f}\textsubscr{ía}.

\newpage

\section{Introducción}

\emph{Esta sección es informativa.}

\subsection{Objetivos}

\begin{enumerate}[1.]
\item
  Familiarizarse con las llamadas al sistema para la creación y acceso a
  las estructuras del sistema de archivos.
\item
  Desarrollar un mecanismo de comunicación entre un proceso y múltiples
  hijos concurrentes utilizando pipes no nominales, señales del sistema
  operativo, y la llamada al sistema \texttt{select}.
\item
  Utilizar la familia de llamadas al sistema \texttt{exec} para que un
  proceso ejecute a otro programa como parte de su ejecución.
\item
  Fortalecer el conocimiento de herramientas de automatización del
  proceso de desarrollo de software como \texttt{make}.
\end{enumerate}
\subsection{\emph{Build system}s}

\begin{enumerate}[1.]
\item
  El proceso de desarrollo de software con cualquier conjunto de
  herramientas implica realizar ciertas tareas repetitivas para
  transformar los datos crudos y el código fuente desarrollados por los
  programadores en un producto terminado que se pueda distribuir y
  utilizar. Si se utilizan lenguajes de programación compilados, este
  proceso incluye la ejecución de compiladores para transformar código
  fuente en ejecutables. Esta tarea puede resultar tediosa en el
  contexto de un proyecto de complejidad considerable, y como el tiempo
  de un desarrollador de software es mejor aprovechado cuando se utiliza
  para desarrollar software, sería deseable eliminar esa carga de
  trabajo con procesos automatizados.
\item
  Un \textbf{\emph{build system}} es un sistema de automatización para
  las tareas de producción de paquetes de software a partir de código y
  datos fuente. Esta definición general incluye sistemas de alcances
  diversos:

  \begin{enumerate}[1.]
  \item
    Los \texttt{Makefile}s simples para compilar alguno de sus proyectos
    pueden ser considerados \emph{build system}s: son programas que
    describen el proceso de construcción de los ejecutables de sus
    proyectos.
  \item
    El programa que interpreta sus \texttt{Makefile}s y ejecuta acciones
    descritas en ellos,
    \href{https://www.gnu.org/software/make}{\texttt{make}}, también
    puede considerarse un \emph{build system}.
  \item
    Existen \emph{build system}s que trabajan a un nivel más alto, como
    \href{https://www.gnu.org/software/automake}{GNU Automake} y
    \href{https://www.gnu.org/software/autoconf}{GNU Autoconf} que son
    dos de los componentes del
    \href{https://www.gnu.org/software/automake/manual/html\_node/GNU-Build-System}{GNU
    build system}, también conocido como \emph{Autotools}. Este sistema
    puede generar \texttt{Makefile}s automáticamente ajustados a las
    peculiaridades de cada tipo de sistema UNIX y cada proyecto, lo que
    lo hace adecuado para proyectos de gran escala que deban funcionar
    en múltiples plataformas.
  \item
    Fuera del mundo de C es común encontrar \emph{build system}s
    asociados a lenguajes y plataformas específicas, como
    \href{https://ant.apache.org/}{Apache Ant} para
    \href{https://java.com/}{Java}, \href{http://scons.org/}{Scons} para
    \href{http://python.org/}{Python},
    \href{http://rake.rubyforge.org/}{Rake} para
    \href{http://www.ruby-lang.org/}{Ruby},
    \href{http://haskell.org/cabal/}{Cabal} para
    \href{http://haskell.org/}{Haskell}, etc. Casi todas estas
    herramientas pueden ser usadas independientemente del lenguaje o la
    plataforma para la cual esté escrito el proyecto al que son
    aplicadas, y ofrecen diversos grados de expresividad y
    automatización: algunas hasta proveen lenguajes de programación
    completos para describir el proceso que automatizan.
  \end{enumerate}
\end{enumerate}
\subsection{Compilación separada por directorios}

\begin{enumerate}[1.]
\item
  En un proyecto de software de escala no trivial resulta conveniente
  dividir la fuente del proyecto en categorías y agrupar los archivos de
  cada una en subdirectorios del directorio del proyecto. Por ejemplo,
  un sistema de documentación de código escrito en C con soporte para
  múltiples lenguajes podría tener una estructura de directorios en su
  código fuente como esta:

\begin{verbatim}
multidoc/             # Directorio principal del proyecto
multidoc/src          # Código fuente del proyecto
multidoc/src/c        # Uso de documentación en código C
multidoc/src/c++      # Uso de documentación en código C++
multidoc/src/asm      # Uso de documentación en código assembly
multidoc/src/asm/x86  # Lenguaje de máquina x86
multidoc/src/asm/mips # Lenguaje de máquina MIPS
multidoc/src/java     # Uso de documentación en código Java
multidoc/lib          # Código de una biblioteca incluida
multidoc/doc          # Documentación del proyecto
multidoc/test         # Pruebas de correctitud del proyecto
\end{verbatim}
\item
  El directorio \texttt{src} y cada uno de sus subdirectorios podrían
  contener varios archivos de código que se compilen de la misma manera
  a archivos de objeto y se combinen finalmente en un ejecutable de todo
  el proyecto. En ese caso, sería conveniente tener en cada
  subdirectorio un \texttt{Makefile} que describa cómo compilar los
  archivos de código de ese subdirectorio, y si contiene a otro
  subdirectorio, que llame a los \texttt{Makefiles} contenidos en ellos.
  Por ejemplo, el \texttt{Makefile} del directorio \texttt{multidoc/src}
  llamará al \texttt{Makefile} del directorio \texttt{multidoc/src/asm},
  que a su vez llamará al \texttt{Makefile} del directorio \texttt{x86}.
  Claro que cada \texttt{Makefile} no debe llamar a solo \emph{uno} de
  los \texttt{Makefiles} de sus subdirectorios, sino a \emph{todos}.
\item
  Los archivos de código (los \texttt{.c}) de cada subdirectorio
  generarán sus correspondientes archivos de objeto compilados (los
  \texttt{.o}). El objetivo del proceso de compilación es reunir todo el
  código generado (todos los \texttt{.o}) para crear finalmente un
  archivo ejecutable en la raíz de la jerarquía de directorios del
  proyecto (que es el producto final del proyecto ficticio
  \texttt{multidoc}). Para facilitar este proceso, en cada subdirectorio
  debería crearse un archivo \texttt{.a} que contenga la \emph{colección
  de todos los \texttt{.o}} de ese subdirectorio. Luego, el
  \emph{directorio padre} de ese subdirectorio podría hacer lo mismo con
  sus archivos de código, y en su colección incluir a las
  \emph{colecciones} (los \texttt{.a}) de todos sus directorios hijos.
\item
  Por ejemplo, suponga que en \texttt{multidoc/src/asm/x86} existen dos
  archivos de código a compilar: \texttt{parse.c} y \texttt{opcodes.c}.
  Suponga además que \texttt{opcodes.c} incluye a un archivo de
  encabezado \texttt{opcodes.h}, y que \texttt{parse.c} incluye a
  \texttt{parse.h}, y \texttt{parse.h} a su vez también incluye a
  \texttt{opcodes.h}. El directorio \texttt{multidoc/src/asm/x86}
  debería contener un \texttt{Makefile} que diga, por ejemplo,
\end{enumerate}
\begin{Shaded}
\begin{Highlighting}[]
        \NormalTok{.PHONY}\CharTok{:} \NormalTok{all}
        \DecValTok{all:} \NormalTok{x86.a}

        \NormalTok{x86.a}\CharTok{:} \NormalTok{parse.o opcodes.o}
        	\NormalTok{ar rT }\CharTok{$}\NormalTok{@ }\CharTok{$}\NormalTok{?}

        \NormalTok{parse.o}\CharTok{:} \NormalTok{parse.c parse.h opcodes.h}
        \NormalTok{opcodes.o}\CharTok{:} \NormalTok{opcodes.c opcodes.h}
\end{Highlighting}
\end{Shaded}
\begin{enumerate}[1.]
\setcounter{enumi}{4}
\item
  El comando

\begin{verbatim}
ar rT archivo.a elemento1 elemento2 ...
\end{verbatim}
  crea un archivo de colección llamado \texttt{archivo.a} que contendrá
  a \texttt{elemento1}, \texttt{elemento2}, etc. Si alguno de esos
  elementos es a su vez un archivo de colección, se almacenarán sus
  elementos por separado en vez del archivo completo. Recuerde que
  \texttt{\$@} en una \emph{receta} de un \texttt{Makefile} se sustituye
  por el nombre del archivo que causó que se corriera esa regla, que en
  este caso, es \texttt{asm.a}; además, \texttt{\$?} se sustituye por
  aquellas dependencias de la regla que deban actualizarse: por ejemplo,
  si acabamos de compilar de nuevo a \texttt{opcodes.c} y obtuvimos una
  nueva versión de \texttt{opcodes.o}, se actualizará la copia de
  \texttt{opcodes.o} en el archivo de colección \texttt{asm.a}, pero si
  no se actualizó \texttt{parse.o}, no se sustituirá su copia en la
  colección (porque no es necesario hacerlo).
\item
  Suponga ahora que se hizo lo mismo en el directorio
  \texttt{multidoc/src/asm/mips}. En el directorio
  \texttt{multidoc/src/asm} sucede lo mismo, excepto que al archivo de
  colección habrá que insertarle los elementos de las colecciones de sus
  subdirectorios:
\end{enumerate}
\begin{Shaded}
\begin{Highlighting}[]
        \NormalTok{.PHONY}\CharTok{:} \NormalTok{all force}
        \DecValTok{all:} \NormalTok{asm.a}

        \NormalTok{asm.a}\CharTok{:} \NormalTok{x86/x86.a mips/mips.a asm.o marmota.o ...}
        	\NormalTok{ar rT }\CharTok{$}\NormalTok{@ }\CharTok{$}\NormalTok{?}

        \NormalTok{x86/x86.a}\CharTok{:} \NormalTok{force}
        	\CharTok{$(}\DataTypeTok{MAKE}\CharTok{)} \NormalTok{-C x86}

        \NormalTok{mips/mips.a}\CharTok{:} \NormalTok{force}
        	\CharTok{$(}\DataTypeTok{MAKE}\CharTok{)} \NormalTok{-C mips}

        \NormalTok{asm.o}\CharTok{:} \NormalTok{asm.c asm.h marmota.h}
        \NormalTok{marmota.o}\CharTok{:} \NormalTok{marmota.c marmota.h}
        \NormalTok{...}
\end{Highlighting}
\end{Shaded}
\begin{enumerate}[1.]
\setcounter{enumi}{6}
\item
  El nuevo archivo de objeto \texttt{x86/x86.a} contendrá todo el código
  compilado correspondiente a ese directorio y a todos sus
  subdirectorios (recursivamente).
\item
  Note que la regla \emph{phony} ``force'' se utiliza como prerequisito
  para los archivos de colección de los subdirectorios; el efecto de
  esto es que \textbf{siempre} se harán las llamadas recursivas a
  \texttt{make} para los subdirectorios. Esto es necesario porque el
  \texttt{Makefile} de un directorio no tiene información sobre si es
  necesario actualizar el código compilado en un subdirectorio. Sin
  embargo, el \texttt{Makefile} que está dentro de ese subdirectorio sí
  será capaz de determinar esto. Por lo tanto, la llamada recursiva se
  hace incondicionalmente, y si había algo que actualizar dentro de un
  subdirectorio, la invocación recursiva de \texttt{make} hará el
  trabajo y actualizará el archivo de colección de ese subdirectorio.
\item
  Finalmente, en el directorio principal del proyecto se compilarán
  todos los archivos compilables que estén directamente en él, y se
  enlazarán todos sus archivos de objeto y todos los archivos de
  colección de los subdirectorios del proyecto. El resultado de esto
  debe ser un ejecutable. En el directorio principal del proyecto podría
  haber, por ejemplo, este \texttt{Makefile}:
\end{enumerate}
\begin{Shaded}
\begin{Highlighting}[]
        \NormalTok{.PHONY}\CharTok{:} \NormalTok{all}
        \DecValTok{all:} \NormalTok{multidoc}

        \DecValTok{multidoc:} \NormalTok{src/src.a lib/lib.a main.o args.o ...}
        	\CharTok{$(}\DataTypeTok{CC}\CharTok{)} \CharTok{$(}\DataTypeTok{CPPFLAGS}\CharTok{)} \CharTok{$(}\DataTypeTok{CCFLAGS}\CharTok{)} \NormalTok{-o }\CharTok{$}\NormalTok{@ }\CharTok{$}\NormalTok{^}

        \NormalTok{src/src.a}\CharTok{:} \NormalTok{force}
        	\CharTok{$(}\DataTypeTok{MAKE}\CharTok{)} \NormalTok{-C src}

        \NormalTok{lib/lib.a}\CharTok{:} \NormalTok{force}
        	\CharTok{$(}\DataTypeTok{MAKE}\CharTok{)} \NormalTok{-C lib}

        \NormalTok{main.o}\CharTok{:} \NormalTok{main.c main.h args.h}
        \NormalTok{args.o}\CharTok{:} \NormalTok{args.c args.h}
        \NormalTok{...}
\end{Highlighting}
\end{Shaded}
\begin{enumerate}[1.]
\setcounter{enumi}{9}
\item
  Recuerde que \texttt{\$\^{}} en una receta de una regla se sustituye
  con los nombres de todos los prerequisitos de la regla separados por
  espacio. La receta mostrada en el ejemplo de \texttt{Makefile}
  anterior genera el ejecutable final del proyecto que contiene todo el
  código compilado de todos los archivos fuente del proyecto.
\item
  Note que no se incluyó \texttt{doc/doc.a} ni \texttt{test/test.a}
  porque presumiblemente esos directorios no se usan en este proyecto
  para almacenar código fuente.
\item
  El objetivo de este proyecto es que escriba en C un \emph{build
  system} que sea capaz de \textbf{generar} los \texttt{Makefile}s en
  situaciones como la de este ejemplo, con la restricción de que el
  procesamiento propio de cada directorio debe hacerse en procesos
  separados que se comuniquen a través de \emph{pipes} y señales del
  sistema operativo.
\item
  Los compiladores de C casi universalmente soportan opciones especiales
  que hacen que en vez de compilar un archivo de código, generen el
  código correspondiente a la regla que debería contener un
  \texttt{Makefile} para compilar y mantener actualizado correctamente
  al archivo de objeto de ese archivo de código. Por ejemplo, en el caso
  del archivo de ejemplo \texttt{parse.c} anteriormente mencionado,
  podría ejecutarse en su directorio el comando

\begin{verbatim}
gcc -E -MMD parse.c
\end{verbatim}
  y se generará otro archivo llamado \texttt{parse.d} cuyo contenido
  será

\begin{verbatim}
parse.o: parse.c parse.h opcodes.h
\end{verbatim}
  que es precisamente lo que debe contener el \texttt{Makefile} que esté
  en el directorio de \texttt{parse.c}. Hay varias variaciones de estas
  opciones; todas comienzan con \texttt{-M}, pero algunas generan un
  archivo con un nombre fijo, otras generan la salida en un archivo cuyo
  nombre es parte de la opción, otras generan el texto de la regla en la
  salida estándar del compilador, etc. El manual de \texttt{gcc}
  describe en detalle todas las opciones que provee para cálculo de
  dependencias para \texttt{Makefile}s.
\end{enumerate}
\pagebreak

\section{Enunciado}

\emph{Esta sección es normativa.}

\subsection{Requerimientos}

\begin{enumerate}[1.]
\item
  Usted debe desarrollar un programa llamado \texttt{rautomake} escrito
  en el lenguaje de programación C.
\item
  \texttt{rautomake} será ejecutado dentro de un cierto directorio. Por
  ejemplo, suponga que el ejecutable de \texttt{rautomake} (que será el
  resultado de que usted haya compilado su proyecto) reside en

\begin{verbatim}
/home/marmota/USB/CI3825/2012EM/P2/src/rautomake
\end{verbatim}
  y usted ejecuta el comando

\begin{verbatim}
../src/rautomake
\end{verbatim}
  en un interpretador de línea de comando cuyo directorio actual es

\begin{verbatim}
/home/marmota/USB/CI3825/2012EM/P2/test
\end{verbatim}
  entonces el directorio donde se ejecuta \texttt{rautomake} será

\begin{verbatim}
/home/marmota/usb/CI3825/2012EM/P2/test
\end{verbatim}
\item
  Es necesario que \texttt{rautomake} cree un \texttt{Makefile} en un
  subdirectorio del directorio donde se ejecutó, o en ese mismo
  directorio, si \texttt{rautomake} tiene permiso de lectura, escritura
  y acceso a ese directorio y a todos sus padres hasta el directorio
  donde fue ejecutado \texttt{rautomake}, inclusive, y en él existen
  archivos para los que \texttt{rautomake} tenga permiso de lectura y
  cuyos nombres terminen en \texttt{.c}, o si es necesario que
  \texttt{rautomake} cree un \texttt{Makefile} en algún subdirectorio
  del directorio en cuestión.
\item
  Cada \texttt{Makefile} que \texttt{rautomake} deba crear deberá
  contener una regla para cada archivo en el directorio de ese
  \texttt{Makefile} cuyo nombre termine en \texttt{.c}. El contenido de
  la regla será el mismo que algún compilador de C generaría al pedirle
  que genere la regla correspondiente a ese archivo para un
  \texttt{Makefile}; debe tener como prerequisitos al menos a todos los
  archivos incluídos directa o indirectamente por el archivo en cuestión
  que estén dentro del directorio en el que fue ejecutado
  \texttt{rautomake}, y no debe tener como prerequisito a ningún archivo
  que no esté incluído ni directa ni indirectamente por el archivo en
  cuestión.
\item
  Cada \texttt{Makefile} que \texttt{rautomake} deba crear en un
  directorio distinto a donde fue ejecutado deberá contener las reglas
  necesarias para crear un archivo de colección con el programa
  \texttt{ar} que contenga la colección de todo el código de objeto
  generado al compilar cada uno de los archivos de ese directorio cuyo
  nombre termine en ``.c'', junto con todo el código de objeto en
  archivos de colección de sus subdirectorios en los que
  \texttt{rautomake} deba crear \texttt{Makefile}s.
\item
  Si \texttt{rautomake} debió crear algún \texttt{Makefile}, entonces
  \texttt{rautomake} deberá crear un \texttt{Makefile} en el directorio
  donde fue ejecutado. Ese \texttt{Makefile} deberá contener una regla
  que cree un archivo ejecutable cuyo nombre sea igual al nombre del
  directorio donde \texttt{rautomake} fue ejecutado; ese archivo
  ejecutable será el resultado de enlazar todos los archivos de objeto
  correspondientes a archivos en el directorio en cuestión cuyos nombres
  terminen en ``.c'', junto con el contenido de los archivos de
  colección correspondientes a los subdirectorios del directorio en
  cuestión en los que \texttt{rautomake} debiera generar un
  \texttt{Makefile}. Los \texttt{Makefile}s que \texttt{rautomake} debe
  crear deben permitir que se genere el ejecutable mencionado en este
  párrafo si se ejecuta la orden \texttt{make} en el mismo directorio
  donde \texttt{rautomake} fue llamado, suponiendo que todos los
  archivos de código compilen y ese ejecutable se pueda generar
  enlazando los resultados de todos los archivos de objeto resultantes.
\item
  \texttt{rautomake} será ejecutado únicamente en directorios cuyos
  nombres estén compuestos únicamente de caracteres alfanuméricos de
  ASCII, o el caracter ``FULL STOP'', también llamado ``punto'' (``.'');
  tampoco tendrán caracteres fuera de ese conjunto los nombres de
  cualquier archivo contenido en los directorios donde
  \texttt{rautomake} sea ejecutado, ni sus subdirectorios, ni los
  archivos contenidos en sus subdirectorios; tampoco será ninguno de
  esos nombres exactamente igual a ``.c''. No es necesario que
  \texttt{rautomake} verifique esto.
\item
  \texttt{rautomake} podrá suponer que no existe ningún archivo dentro
  del directorio donde es ejecutado, ni dentro de ninguno de sus
  subdirectorios, cuyo nombre termine en ``.d''. Si tales archivos
  existen, \texttt{rautomake} podrá eliminarlos o sobreescribirlos para
  cualquier fin. \texttt{rautomake} no será ejecutado en un directorio
  donde existan archivos con nombres de esa forma sobre los que no tenga
  permiso de lectura y escritura. \texttt{rautomake} no será ejecutado
  en un directorio cuyo nombre termine en ``.d'', ni que tenga algún
  subdirectorio cuyo nombre termine en ``.d''.
\item
  Un proceso de \texttt{rautomake} no puede visitar, abrir ni manipular
  más de un directorio a lo largo de su ejecución, a menos que ese
  proceso sea un compilador de C. Si un proceso de \texttt{rautomake}
  que no sea un compilador de C requiere visitar, abrir o manipular más
  de un directorio, deberá copiarse a sí mismo y una de sus copias podrá
  visitar, abrir o manipular un directorio distinto al visitado, abierto
  o manipulado por el proceso original.
\item
  La comunicación entre varios procesos resultantes de una ejecución de
  \texttt{rautomake} solo podrá hacerse a través de \emph{pipes} no
  nominales y/o señales del sistema operativo, a menos que uno de los
  procesos involucrados sea un compilador de C, en cuyo caso es
  aceptable la comunicación a través de archivos.
\item
  A menos que este documento haga una excepción explícita particular,
  \texttt{rautomake} \textbf{debe} manejar explícitamente absolutamente
  todos los efectos y resultados de llamadas al sistema o a bibliotecas
  que puedan afectar al flujo de ejecución de su implementación de
  \texttt{rautomake}. En particular, si su implementación de
  \texttt{rautomake} deja de revisar una posible condición de error en
  el retorno de una llamada al sistema o a alguna biblioteca que
  utilice, incluyendo la biblioteca estándar de C, se esperará que usted
  pueda demostrar que el flujo de ejecución de su programa nunca depende
  de esa condición.
\end{enumerate}
\subsection{Entrega}

\begin{enumerate}[1.]
\item
  El código principal de \texttt{rautomake} debe estar escrito en el
  lenguaje de programación C en cualquiera de sus versiones, debe poder
  compilarse con las herramientas GNU disponibles en la versión estable
  más reciente al momento de la entrega de Debian GNU/Linux, y, en
  particular, debe poder compilarse y ejecutarse en las computadoras del
  LDC.
\item
  La entrega consistirá de un archivo en formato \texttt{tar.gz} o
  \texttt{tar.bz2} que contenga todo el código que haya desarrollado y
  sea necesario para compilar su programa. No debe incluir archivos
  compilados. Su proyecto debe poder compilarse extrayendo los archivos
  del paquete de su entrega, entrando en el directorio generado por la
  extracción, y ejecutando el comando \texttt{make}; es decir que
  \emph{debe} incluir al menos un \texttt{Makefile} para automatizar la
  compilación de su proyecto.
\item
  Aunque en general es preferible que su código sea compatible con los
  documentos de estandarización más recientes publicados para cada
  tecnología que utilice, es aceptable que requiera y use extensiones
  propias de la implementación de las herramientas de la plataforma
  GNU/Linux tanto del lenguaje de programación C como de la interfaz con
  el sistema operativo. Es aceptable que requiera alguna versión de las
  herramientas del sistema diferente de las que están instaladas y
  disponibles en la versión estable más reciente al momento de la
  entrega de Debian GNU/Linux, y en particular de lo que esté instalado
  y disponible en las computadoras del LDC, pero deberá justificar estos
  requerimientos adicionales.
\end{enumerate}
\pagebreak

\section{Información adicional}

\emph{Esta sección es informativa.}

\begin{enumerate}[1.]
\item
  Este proyecto está diseñado para instruir en el uso del lenguaje C,
  herramientas de desarrollo de software como \texttt{make} y
  \texttt{gcc}, y la interfaz de programación de los sistemas operativos
  que implementan los estándares POSIX\footnote{\href{http://pubs.opengroup.org/onlinepubs/9699919799}{Documentos
    de POSIX.1‐2008} (también llamado ``IEEE Std 1003.1™‐2008'', o ``The
    Open Group Technical Standard Base Specifications, Issue 7'')}, y
  particularmente todo lo relacionado con el acceso a archivos y
  directorios y la comunicación entre procesos. El diseño del proyecto,
  y por lo tanto de la herramienta que usted debe implementar, está
  orientado a ese propósito educativo y no necesariamente obedece a los
  criterios de diseño adecuados para la creación de un \emph{build
  system}.
\item
  En particular, aunque el uso recursivo de \texttt{make} que este
  proyecto propone es sin duda muy similar a las prácticas comunes de
  muchos proyectos de software de gran envergadura, esta técnica sufre
  de problemas importantes y hay buenas razones para \emph{no} usarla.
  Varios de estos problemas se exploran en Miller, 1997\footnote{\href{http://miller.emu.id.au/pmiller/books/rmch/}{Peter
    Miller --- Recursive make considered harmful (1997)}} (disponible en
  \href{http://aegis.sourceforge.net/auug97.pdf}{PDF}); ese artículo es
  un buen comienzo si es de su interés conocer la manera \emph{correcta}
  de usar \texttt{make} con proyectos divididos en múltiples
  directorios.
\end{enumerate}

\end{document}
