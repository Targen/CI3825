> Tengo otra duda: Para copiar lo que esta en un archivo a otro.. Tendria que leer de uno y escribir en el otro.

> Pero como podria hacer para saber el tamano de lo que voy a leer(en realidad quiero leer toda la linea)?... Podria leer caracter por caracter pero alguna vez nos dijeron que eso no era bueno..entonces no se..

En efecto leer caracter por caracter es una opción indeseable: es decirle al sistema de operación que bloquee el proceso hasta que sea leído ese caracter, y luego se requiere pasar a estado *running* únicamente para pedirle al sistema operativo que escriba ese caracter en el otro archivo, todo eso por cada uno de los caracteres del archivo.  Esto es lentísimo por la cantidad de veces que el proceso se bloquea.

La técnica sencilla y básica para mejorar esto es leer por lotes: su programa puede tener un espacio de memoria (un *buffer*) de un cierto tamaño (probablemente fijo) que se use para almacenar temporalmente una parte del archivo que se leyó, y así poder escribir el contenido de ese *buffer* cuando se termina de leer un lote de los datos a copiar, y luego volver a empezar.  En el caso de un *buffer* de exactamente un caracter, esta técnica, claro, se reduce a la anterior y es lenta.

Otra técnica es determinar el tamaño del archivo a copiar usando funciones del sistema de archivo que provean esa información (como `stat`) y crear un *buffer* en la memoria del programa suficientemente grande para almacenar su contenido completo.  Este es, claro, el extremo opuesto de la primera técnica.  Normalmente es la técnica más rápida (*modulo* el impacto de la paginación de la memoria y demás), pero consume cantidades de memoria que podrían ser excesivas, y se arriesga a que el proceso falle por tratar de manipular un archivo muy grande y que se agote la memoria del sistema.

Existen técnicas más modernas que resuelven el problema transfiriéndolo al sistema de operación, que seguramente sabrá aproximarse mejor al óptimo: es posible hacer un *mapeo* del contenido de un archivo al espacio de memoria de un proceso; cuando el proceso desea leer de o escribir a una posición de memoria que representa una posición en un archivo, el sistema de operación se encarga de traducir eso en la acción correspondiente sobre el archivo *mapeado*.  Otra ventaja de esta técnica es que el código usado para acceder a una posición de un archivo se convierte en un simple acceso a un arreglo en la memoria como cualquier otro, así que la programación se facilita cuando las operaciones hechas sobre el archivo son de cierta complejidad.  La desventaja es que hay que aprender a usar estos *mapeos* de memoria y su semántica puede ser un poco difícil de asimilar en un principio (pero, claro, eso se aprende una sola vez y de ahí en adelante simplifica la vida permanentemente).

Como el enunciado no establece requerimientos de eficiencia (y realmente son pequeños los datos que hay que copiar) pueden hacerlo como quieran.

La técnica de *mapeos* de memoria es algo que vale la pena aprender, así que se las recomiendo si tienen algo de tiempo para dedicarle; si terminan dedicándose a hacer software sujeto a restricciones de eficiencia o que sea de escala masiva (básicamente cualquier cosa que valga la pena hacer fuera del mundo académico), les será necesario saber trabajar con eso.  Si tienen poco tiempo, recuerden que la técnica de copiar un byte a la vez es válida y simple, pero no les enseñará absolutamente nada.  La técnica del *buffer* es casi tan simple como la de copiar un byte a la vez, y claro, es casi tan aburrida.

Si deciden usar *mapeos* de memoria, lean sobre la función `mmap`.  No es nada difícil de usar.  El único detalle es que no es buena idea (y por lo general) usarlas para operaciones que puedan modificar el tamaño del archivo *mapeado*, así que sería más para la lectura que para la escritura.  Por cierto, `fprintf(out_file, "%*s", n, map_ptr)` lee `n` caracteres desde la posición de memoria apuntada por `map_ptr` y los escribe a `out_file`; si usan eso, la copia sale en muy poco código y será extremadamente eficiente.

